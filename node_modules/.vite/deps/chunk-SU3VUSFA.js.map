{
  "version": 3,
  "sources": ["../../@gcornut/valibot-json-schema/dist/index.mjs"],
  "sourcesContent": ["// src/extension/withJSONSchemaFeatures.ts\nvar JSON_SCHEMA_FEATURES_KEY = \"__json_schema_features\";\nfunction withJSONSchemaFeatures(schema, features) {\n  return Object.assign(schema, { [JSON_SCHEMA_FEATURES_KEY]: features });\n}\nfunction getJSONSchemaFeatures(schema) {\n  return schema[JSON_SCHEMA_FEATURES_KEY];\n}\n\n// src/extension/assignExtraJSONSchemaFeatures.ts\nfunction assignExtraJSONSchemaFeatures(schema, converted) {\n  const jsonSchemaFeatures = getJSONSchemaFeatures(schema);\n  if (jsonSchemaFeatures) {\n    Object.assign(converted, jsonSchemaFeatures);\n  }\n}\n\n// src/utils/assert.ts\nfunction assert(value, predicate, message) {\n  if (!predicate(value)) throw new Error(message.replace(\"%\", String(value)));\n  return value;\n}\n\n// src/utils/json-schema.ts\nvar $schema = \"http://json-schema.org/draft-07/schema#\";\nfunction isJSONLiteral(value) {\n  return typeof value === \"number\" && !Number.isNaN(value) || typeof value === \"string\" || typeof value === \"boolean\" || value === null;\n}\nvar assertJSONLiteral = (v) => assert(v, isJSONLiteral, \"Unsupported literal value type: %\");\n\n// src/toJSONSchema/schemas.ts\nimport {\n  getDefault,\n  never\n} from \"valibot\";\n\n// src/utils/isEqual.ts\nfunction isEqual(obj1, obj2) {\n  if (obj1 === obj2) return true;\n  if (typeof obj1 === \"object\" && typeof obj2 === \"object\") {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key1) => isEqual(obj1[key1], obj2[key1]));\n  }\n  return false;\n}\n\n// src/utils/valibot.ts\nfunction isSchemaType(type) {\n  return (schema) => {\n    return !!schema && schema.type === type;\n  };\n}\nvar isNullishSchema = isSchemaType(\"nullish\");\nvar isOptionalSchema = isSchemaType(\"optional\");\nvar isStringSchema = isSchemaType(\"string\");\nvar isNeverSchema = isSchemaType(\"never\");\n\n// src/toJSONSchema/toDefinitionURI.ts\nvar toDefinitionURI = (name) => `#/definitions/${name}`;\n\n// src/toJSONSchema/schemas.ts\nvar SCHEMA_CONVERTERS = {\n  any: () => ({}),\n  // Core types\n  null: () => ({ const: null }),\n  literal: ({ literal }) => ({ const: assertJSONLiteral(literal) }),\n  number: () => ({ type: \"number\" }),\n  string: () => ({ type: \"string\" }),\n  boolean: () => ({ type: \"boolean\" }),\n  // Compositions\n  optional: (schema, convert) => {\n    const output = convert(schema.wrapped);\n    const defaultValue = getDefault(schema);\n    if (defaultValue !== void 0) output.default = defaultValue;\n    return output;\n  },\n  nullish: (schema, convert) => {\n    const output = { anyOf: [{ const: null }, convert(schema.wrapped)] };\n    const defaultValue = getDefault(schema);\n    if (defaultValue !== void 0) output.default = defaultValue;\n    return output;\n  },\n  nullable: (schema, convert) => {\n    const output = { anyOf: [{ const: null }, convert(schema.wrapped)] };\n    const defaultValue = getDefault(schema);\n    if (defaultValue !== void 0) output.default = defaultValue;\n    return output;\n  },\n  picklist: ({ options }) => ({ enum: options.map(assertJSONLiteral) }),\n  enum: (options) => ({ enum: Object.values(options.enum).map(assertJSONLiteral) }),\n  union: ({ options }, convert) => ({ anyOf: options.map(convert) }),\n  intersect: ({ options }, convert) => ({ allOf: options.map(convert) }),\n  // Complex types\n  array: ({ item }, convert) => ({ type: \"array\", items: convert(item) }),\n  tuple_with_rest({ items: originalItems, rest }, convert) {\n    const minItems = originalItems.length;\n    let maxItems;\n    let items = originalItems.map(convert);\n    let additionalItems;\n    if (isNeverSchema(rest)) {\n      maxItems = minItems;\n    } else if (rest) {\n      const restItems = convert(rest);\n      if (items.length === 1 && isEqual(items[0], restItems)) {\n        items = items[0];\n      } else {\n        additionalItems = restItems;\n      }\n    }\n    return {\n      type: \"array\",\n      items,\n      ...additionalItems && { additionalItems },\n      ...minItems && { minItems },\n      ...maxItems && { maxItems }\n    };\n  },\n  strict_tuple({ items: originalItems }, convert) {\n    const items = originalItems.map(convert);\n    return { type: \"array\", items, minItems: items.length, maxItems: items.length };\n  },\n  tuple({ items: originalItems }, convert, context) {\n    const items = originalItems.map(convert);\n    return { type: \"array\", items, minItems: items.length };\n  },\n  object_with_rest({ entries, rest }, convert, context) {\n    const properties = {};\n    const required = [];\n    for (const [propKey, propValue] of Object.entries(entries)) {\n      const propSchema = propValue;\n      if (!isOptionalSchema(propSchema) && !isNullishSchema(propSchema)) {\n        required.push(propKey);\n      }\n      properties[propKey] = convert(propSchema);\n      assignExtraJSONSchemaFeatures(propValue, properties[propKey]);\n    }\n    let additionalProperties;\n    if (rest) {\n      additionalProperties = isNeverSchema(rest) ? false : convert(rest);\n    } else if (context.strictObjectTypes) {\n      additionalProperties = false;\n    }\n    const output = { type: \"object\", properties };\n    if (additionalProperties !== void 0) output.additionalProperties = additionalProperties;\n    if (required.length) output.required = required;\n    return output;\n  },\n  object(schema, convert, context) {\n    return SCHEMA_CONVERTERS.object_with_rest(schema, convert, context);\n  },\n  strict_object(schema, convert, context) {\n    return SCHEMA_CONVERTERS.object_with_rest({ ...schema, rest: never() }, convert, context);\n  },\n  record({ key, value }, convert) {\n    assert(key, isStringSchema, \"Unsupported record key type: %\");\n    return { type: \"object\", additionalProperties: convert(value) };\n  },\n  lazy(schema, _, context) {\n    const nested = schema.getter({});\n    const defName = context.defNameMap.get(nested);\n    if (!defName) {\n      throw new Error(\"Type inside lazy schema must be provided in the definitions\");\n    }\n    return { $ref: toDefinitionURI(defName) };\n  },\n  date(_, __, context) {\n    if (!context.dateStrategy) {\n      throw new Error('The \"dateStrategy\" option must be set to handle date validators');\n    }\n    switch (context.dateStrategy) {\n      case \"integer\":\n        return { type: \"integer\", format: \"unix-time\" };\n      case \"string\":\n        return { type: \"string\", format: \"date-time\" };\n    }\n  },\n  undefined(_, __, context) {\n    if (!context.undefinedStrategy) {\n      throw new Error('The \"undefinedStrategy\" option must be set to handle the `undefined` schema');\n    }\n    switch (context.undefinedStrategy) {\n      case \"any\":\n        return {};\n      case \"null\":\n        return { type: \"null\" };\n    }\n  },\n  bigint(_, __, context) {\n    if (!context.bigintStrategy) {\n      throw new Error('The \"bigintStrategy\" option must be set to handle `bigint` validators');\n    }\n    switch (context.bigintStrategy) {\n      case \"integer\":\n        return { type: \"integer\", format: \"int64\" };\n      case \"string\":\n        return { type: \"string\" };\n    }\n  },\n  variant({ options }, ...args) {\n    return SCHEMA_CONVERTERS.union({ options }, ...args);\n  }\n};\n\n// src/toJSONSchema/validations.ts\nvar VALIDATION_BY_SCHEMA = {\n  array: {\n    length: ({ requirement }) => ({ minItems: requirement, maxItems: requirement }),\n    min_length: ({ requirement }) => ({ minItems: requirement }),\n    max_length: ({ requirement }) => ({ maxItems: requirement })\n  },\n  string: {\n    value: ({ requirement }) => ({ const: requirement }),\n    length: ({ requirement }) => ({ minLength: requirement, maxLength: requirement }),\n    min_length: ({ requirement }) => ({ minLength: requirement }),\n    max_length: ({ requirement }) => ({ maxLength: requirement }),\n    // TODO: validate RegExp features are compatible with json schema ?\n    regex: ({ requirement }) => ({ pattern: requirement.source }),\n    email: () => ({ format: \"email\" }),\n    iso_date: () => ({ format: \"date\" }),\n    iso_timestamp: () => ({ format: \"date-time\" }),\n    ipv4: () => ({ format: \"ipv4\" }),\n    ipv6: () => ({ format: \"ipv6\" }),\n    uuid: () => ({ format: \"uuid\" })\n  },\n  number: {\n    value: ({ requirement }) => ({ const: requirement }),\n    min_value: ({ requirement }) => ({ minimum: requirement }),\n    max_value: ({ requirement }) => ({ maximum: requirement }),\n    multiple_of: ({ requirement }) => ({ multipleOf: requirement }),\n    integer: () => ({ type: \"integer\" })\n  },\n  boolean: {\n    value: ({ requirement }) => ({ const: requirement })\n  },\n  date: {\n    value: ({ requirement }, context) => ({ const: asDateRequirement(\"value\", requirement, context) }),\n    min_value: ({ requirement }, context) => ({ minimum: asDateRequirement(\"minValue\", requirement, context) }),\n    max_value: ({ requirement }, context) => ({ maximum: asDateRequirement(\"maxValue\", requirement, context) })\n  }\n};\nfunction asDateRequirement(type, requirement, context) {\n  assert(requirement, () => context.dateStrategy === \"integer\", `${type} validation is only available with 'integer' date strategy`);\n  assert(requirement, (r) => r instanceof Date, `Non-date value used for ${type} validation`);\n  return requirement.getTime();\n}\nfunction convertPipe(schemaType, pipe, context) {\n  const [schema, ...pipeItems] = pipe || [];\n  if (!schema) return {};\n  const childPipe = convertPipe(schemaType, schema == null ? void 0 : schema.pipe, context);\n  function convertPipeItem(def, validation) {\n    var _a, _b, _c;\n    const validationType = validation.type;\n    const validationConverter = ((_b = (_a = context.customValidationConversion) == null ? void 0 : _a[schemaType]) == null ? void 0 : _b[validationType]) || ((_c = VALIDATION_BY_SCHEMA[schemaType]) == null ? void 0 : _c[validationType]);\n    if (!validationConverter && context.ignoreUnknownValidation) return {};\n    assert(validationConverter, Boolean, `Unsupported valibot validation \\`${validationType}\\` for schema \\`${schemaType}\\``);\n    const converted = validationConverter(validation, context);\n    return Object.assign(def, converted);\n  }\n  return pipeItems.reduce(convertPipeItem, childPipe);\n}\n\n// src/toJSONSchema/index.ts\nfunction getDefNameMap(definitions = {}) {\n  const map = /* @__PURE__ */ new Map();\n  for (const [name, definition] of Object.entries(definitions)) {\n    map.set(definition, name);\n  }\n  return map;\n}\nfunction createConverter(context) {\n  const definitions = {};\n  function converter(schema) {\n    var _a;\n    const defName = context.defNameMap.get(schema);\n    const defURI = defName && toDefinitionURI(defName);\n    if (defURI && defURI in definitions) {\n      return { $ref: defURI };\n    }\n    const schemaConverter = ((_a = context.customSchemaConversion) == null ? void 0 : _a[schema.type]) || SCHEMA_CONVERTERS[schema.type];\n    assert(schemaConverter, Boolean, `Unsupported valibot schema: ${(schema == null ? void 0 : schema.type) || schema}`);\n    let converted = schemaConverter(schema, converter, context) || {};\n    const convertedValidation = convertPipe(schema.type, schema.pipe, context);\n    converted = { ...converted, ...convertedValidation };\n    assignExtraJSONSchemaFeatures(schema, converted);\n    if (defURI) {\n      definitions[defName] = converted;\n      return { $ref: defURI };\n    }\n    return converted;\n  }\n  return { definitions, converter };\n}\nfunction toJSONSchema(options) {\n  const { schema, definitions: inputDefinitions, ...more } = options;\n  const defNameMap = getDefNameMap(inputDefinitions);\n  const { definitions, converter } = createConverter({ defNameMap, ...more });\n  if (!schema && !inputDefinitions) {\n    throw new Error(\"No main schema or definitions provided.\");\n  }\n  if (inputDefinitions) {\n    Object.values(inputDefinitions).forEach(converter);\n  }\n  const mainConverted = schema && converter(schema);\n  const mainDefName = schema && defNameMap.get(schema);\n  const out = { $schema };\n  if (mainDefName) {\n    out.$ref = toDefinitionURI(mainDefName);\n  } else {\n    Object.assign(out, mainConverted);\n  }\n  if (Object.keys(definitions).length) {\n    out.definitions = definitions;\n  }\n  return out;\n}\nexport {\n  toJSONSchema,\n  withJSONSchemaFeatures\n};\n"],
  "mappings": "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",
  "names": []
}
